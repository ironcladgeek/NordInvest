"""AI-powered technical analysis agent using LLM for intelligent analysis.

This module provides an LLM-based technical analysis agent that generates
comprehensive, context-aware analysis with natural language rationale.

Key Differences from TechnicalAnalysisAgent:
    - TechnicalAnalysisAgent: Rule-based scoring with hardcoded logic
    - AITechnicalAnalysisAgent: LLM-powered with dynamic, context-aware reasoning

The AITechnicalAnalysisAgent leverages large language models to:
    1. Interpret technical indicators holistically
    2. Generate nuanced, natural language rationale
    3. Consider market context and recent patterns
    4. Provide actionable insights beyond simple scoring
"""

from typing import Any

from pydantic import BaseModel, Field

from src.agents.base import AgentConfig, BaseAgent
from src.tools.analysis import TechnicalIndicatorTool
from src.tools.fetchers import PriceFetcherTool
from src.utils.logging import get_logger

logger = get_logger(__name__)


class AITechnicalAnalysisOutput(BaseModel):
    """Structured output for AI technical analysis.

    This model captures the comprehensive analysis generated by the LLM,
    including scores, recommendations, detailed natural language reasoning,
    and specific trading levels for tactical execution.
    """

    ticker: str = Field(description="Stock ticker symbol")
    technical_score: float = Field(description="Overall technical score (0-100)", ge=0, le=100)
    confidence: float = Field(description="Confidence level in the analysis (0-100)", ge=0, le=100)
    recommendation: str = Field(
        description="Trading recommendation: strong_buy, buy, hold, sell, strong_sell"
    )
    action: str = Field(description="Suggested action for watchlist: Buy, Wait, Remove")
    rationale: str = Field(
        description="Fact-based, tactical explanation that provides specific entry guidance. "
        "For BUY actions: Include specific entry price zones, stop loss levels, and take profit targets. "
        "For WAIT actions: Explain what price level or technical condition to wait for. "
        "For REMOVE actions: Explain the bearish technical breakdown. "
        "Base all statements on recent price action and current technical indicator values."
    )
    key_signals: list[str] = Field(
        default_factory=list,
        description="List of 2-4 key technical signals or observations that drive the analysis",
    )
    risk_factors: list[str] = Field(
        default_factory=list,
        description="List of 1-3 potential risks or caveats to consider",
    )
    trend: str = Field(description="Overall trend assessment: bullish, bearish, neutral")
    entry_timing: str = Field(
        description="Entry timing assessment: immediate, wait_for_pullback, "
        "wait_for_breakout, avoid"
    )
    entry_price: float | None = Field(
        default=None,
        description="Suggested entry price or price zone (based on support levels, moving averages). "
        "Only provided for Buy actions. Should be current price or slightly below for better entry.",
    )
    stop_loss: float | None = Field(
        default=None,
        description="Suggested stop loss level (based on recent swing lows, ATR, support levels). "
        "Only provided for Buy actions. Typically 3-5% below entry or at key support.",
    )
    take_profit: float | None = Field(
        default=None,
        description="Suggested take profit target (based on resistance levels, Fibonacci, risk:reward ratio). "
        "Only provided for Buy actions. Should provide at least 2:1 risk:reward ratio.",
    )
    wait_for_price: float | None = Field(
        default=None,
        description="Price level to wait for if action is Wait (e.g., pullback to support, breakout level). "
        "Helps traders set price alerts for better entry opportunities.",
    )


class AITechnicalAnalysisAgent(BaseAgent):
    """LLM-powered technical analysis agent.

    This agent uses large language models to perform sophisticated technical analysis,
    generating natural language insights and recommendations based on calculated
    technical indicators.

    Key Features:
        - Leverages LLM for nuanced interpretation of technical indicators
        - Generates comprehensive, context-aware rationale
        - Provides actionable trading insights beyond simple scoring
        - Considers multiple timeframes and indicator correlations

    Differences from TechnicalAnalysisAgent:
        - TechnicalAnalysisAgent: Fast, rule-based, deterministic scoring
        - AITechnicalAnalysisAgent: Slower, LLM-based, context-aware reasoning

    Use Cases:
        - Watchlist monitoring with detailed explanations
        - Educational analysis for learning technical patterns
        - High-confidence trades requiring comprehensive review

    Not Recommended For:
        - High-frequency scanning of many tickers (use TechnicalAnalysisAgent)
        - Cost-sensitive batch operations
        - Simple binary buy/sell decisions
    """

    def __init__(
        self,
        tools: list | None = None,
        llm_client=None,
        config=None,
        prompt_mode: str = "tactical",
    ):
        """Initialize AI Technical Analysis agent.

        Args:
            tools: Optional list of tools (defaults to price and indicator tools)
            llm_client: LLM client instance for generating analysis
            config: Configuration object with LLM settings
            prompt_mode: Analysis mode - 'tactical' (specific levels, actionable) or 'general' (overview)
        """
        agent_config = AgentConfig(
            role="AI Technical Analyst",
            goal="Provide comprehensive, LLM-powered technical analysis with detailed reasoning",
            backstory=(
                "You are an AI-powered technical analyst with deep expertise in "
                "interpreting price patterns, technical indicators, and market dynamics. "
                "You combine quantitative indicator analysis with qualitative market context "
                "to provide nuanced, actionable trading insights. Your analysis goes beyond "
                "simple rule-based scoring to consider indicator correlations, market regime, "
                "and recent price action patterns."
            ),
        )
        default_tools = [PriceFetcherTool(), TechnicalIndicatorTool()]
        super().__init__(agent_config, tools or default_tools)

        self.llm_client = llm_client
        self.config = config
        self.prompt_mode = prompt_mode

    def execute(self, task: str, context: dict[str, Any] | None = None) -> dict[str, Any]:
        """Execute AI-powered technical analysis.

        Args:
            task: Task description
            context: Context with ticker, llm_client, and optional parameters

        Returns:
            Technical analysis results with LLM-generated insights
        """
        try:
            context = context or {}
            ticker = context.get("ticker")

            if not ticker:
                return {
                    "status": "error",
                    "message": "No ticker provided",
                    "technical_score": 0,
                }

            # Use LLM client from context if not provided at initialization
            llm_client = context.get("llm_client") or self.llm_client
            if not llm_client:
                return {
                    "status": "error",
                    "message": "LLM client not available",
                    "technical_score": 0,
                }

            logger.debug(f"AI technical analysis for {ticker}")

            # Get price data
            price_fetcher = next(
                (t for t in self.tools if hasattr(t, "name") and t.name == "PriceFetcher"),
                None,
            )

            if not price_fetcher:
                return {
                    "status": "error",
                    "message": "Price fetcher unavailable",
                    "technical_score": 0,
                }

            # Set historical date if provided
            if "analysis_date" in context and hasattr(price_fetcher, "set_historical_date"):
                price_fetcher.set_historical_date(context["analysis_date"])

            # Fetch price data
            lookback_days = context.get("historical_data_lookback_days", 730)
            price_data = price_fetcher.run(ticker, days_back=lookback_days)

            if "error" in price_data:
                return {
                    "status": "error",
                    "message": price_data["error"],
                    "technical_score": 0,
                }

            # Calculate technical indicators
            tech_tool = next(
                (t for t in self.tools if hasattr(t, "name") and t.name == "TechnicalIndicator"),
                None,
            )

            if not tech_tool:
                return {
                    "status": "error",
                    "message": "Technical indicator tool unavailable",
                    "technical_score": 0,
                }

            indicators = tech_tool.run(price_data.get("prices", []))

            if "error" in indicators:
                return {
                    "status": "error",
                    "message": indicators["error"],
                    "technical_score": 0,
                }

            # Generate LLM-powered analysis
            analysis_result = self._generate_llm_analysis(ticker, indicators, llm_client, context)

            if "error" in analysis_result:
                return {
                    "status": "error",
                    "message": analysis_result["error"],
                    "technical_score": 0,
                }

            logger.debug(
                f"AI technical analysis for {ticker}: {analysis_result['technical_score']:.0f}/100"
            )

            return {
                "status": "success",
                **analysis_result,
            }

        except Exception as e:
            logger.error(f"Error during AI technical analysis: {e}", exc_info=True)
            return {
                "status": "error",
                "message": str(e),
                "technical_score": 0,
            }

    def _generate_llm_analysis(
        self,
        ticker: str,
        indicators: dict[str, Any],
        llm_client,
        context: dict[str, Any],
    ) -> dict[str, Any]:
        """Generate comprehensive technical analysis using LLM.

        Args:
            ticker: Stock ticker symbol
            indicators: Calculated technical indicators
            llm_client: LLM client for generating analysis
            context: Additional context

        Returns:
            Dictionary with analysis results
        """
        try:
            # Prepare indicator summary for LLM
            indicator_summary = self._format_indicators_for_llm(indicators)

            # Build the system prompt
            system_prompt = self._build_system_prompt()

            # Build the user prompt
            user_prompt = self._build_user_prompt(ticker, indicator_summary)

            # Get structured output from LLM using LangChain interface
            try:
                # Use LangChain's with_structured_output for Pydantic model
                structured_llm = llm_client.with_structured_output(AITechnicalAnalysisOutput)

                # Prepare messages for LangChain
                from langchain_core.messages import HumanMessage, SystemMessage

                messages = [
                    SystemMessage(content=system_prompt),
                    HumanMessage(content=user_prompt),
                ]

                # Invoke the structured LLM
                validated = structured_llm.invoke(messages)

                # Convert to dict and add additional fields for compatibility
                result_dict = validated.model_dump()
                result_dict["indicators"] = indicators  # Include raw indicators
                result_dict["current_price"] = indicators.get("latest_price", 0)
                result_dict["rsi"] = indicators.get("rsi")  # Add RSI to top level

                return result_dict

            except Exception as e:
                logger.error(f"LLM analysis failed: {e}")
                return {"error": f"LLM analysis failed: {str(e)}"}

        except Exception as e:
            logger.error(f"Error generating LLM analysis: {e}")
            return {"error": str(e)}

    def _format_indicators_for_llm(self, indicators: dict[str, Any]) -> str:
        """Format technical indicators into a readable summary for LLM.

        Args:
            indicators: Dictionary of calculated indicators

        Returns:
            Formatted string summary
        """
        lines = []

        # Price and trend
        if "latest_price" in indicators:
            lines.append(f"Current Price: ${indicators['latest_price']:.2f}")
        if "trend" in indicators:
            lines.append(f"Overall Trend: {indicators['trend']}")

        # Momentum indicators
        lines.append("\n## Momentum Indicators:")
        if "rsi" in indicators:
            lines.append(f"  - RSI (14): {indicators['rsi']:.2f}")
        if "macd_line" in indicators:
            lines.append(f"  - MACD Line: {indicators['macd_line']:.4f}")
        if "macd_signal" in indicators:
            lines.append(f"  - MACD Signal: {indicators['macd_signal']:.4f}")
        if "macd_histogram" in indicators:
            lines.append(f"  - MACD Histogram: {indicators['macd_histogram']:.4f}")

        # Moving averages
        lines.append("\n## Moving Averages:")
        if "sma_20" in indicators:
            lines.append(f"  - SMA 20: ${indicators['sma_20']:.2f}")
        if "sma_50" in indicators:
            lines.append(f"  - SMA 50: ${indicators['sma_50']:.2f}")
        if "ema_12" in indicators:
            lines.append(f"  - EMA 12: ${indicators['ema_12']:.2f}")
        if "ema_26" in indicators:
            lines.append(f"  - EMA 26: ${indicators['ema_26']:.2f}")

        # Volatility and volume
        lines.append("\n## Volatility & Volume:")
        if "atr" in indicators:
            lines.append(f"  - ATR (14): {indicators['atr']:.4f}")
        if "volume_ratio" in indicators:
            lines.append(f"  - Volume Ratio: {indicators['volume_ratio']:.2f}x average")

        # Bollinger Bands
        if "bbands_upper" in indicators:
            lines.append("\n## Bollinger Bands:")
            lines.append(f"  - Upper: ${indicators.get('bbands_upper', 0):.2f}")
            lines.append(f"  - Middle: ${indicators.get('bbands_middle', 0):.2f}")
            lines.append(f"  - Lower: ${indicators.get('bbands_lower', 0):.2f}")

        return "\n".join(lines)

    def _build_system_prompt(self) -> str:
        """Build system prompt for LLM technical analysis."""
        base_prompt = """You are a highly experienced technical analyst and professional trader specializing in tactical trade execution.

Your expertise includes:
- Chart pattern recognition and interpretation
- Technical indicator analysis (RSI, MACD, Moving Averages, Bollinger Bands, ATR)
- Trend identification and momentum assessment
- Support/resistance level identification
- Risk management and position sizing
- Entry/exit timing and trade planning

Your analysis should be:
1. FACT-BASED: Reference specific indicator values and recent price action
2. TACTICAL: Provide specific entry prices, stop losses, and profit targets
3. ACTIONABLE: Give clear, executable trading guidance
4. RISK-AWARE: Always include stop loss and risk:reward considerations
5. PRECISE: Use actual numbers from the data, not general statements

Scoring Guidelines:
- technical_score: 0-100 scale (0=strong sell, 50=neutral, 100=strong buy)
- confidence: 0-100 based on indicator agreement and signal clarity

Recommendation Mapping:
- 75-100: strong_buy
- 60-74: buy
- 40-59: hold
- 25-39: sell
- 0-24: strong_sell
"""

        if self.prompt_mode == "tactical":
            base_prompt += """
TACTICAL MODE - Action-Specific Guidance:

For BUY actions:
- Set entry_price: Current price or slightly below (e.g., at moving average support)
- Set stop_loss: Below recent swing low or 3-5% below entry (use ATR for guidance)
- Set take_profit: At resistance level or 2-3x the risk (minimum 2:1 reward:risk)
- Rationale MUST include: "Based on [specific indicators], consider entering around $X with stop loss at $Y and take profit at $Z"

For WAIT actions:
- Set wait_for_price: Specific pullback level or breakout price to monitor
- Rationale MUST include: "Wait for price to pullback to $X (support level) or break above $Y (resistance)"
- Explain what technical condition needs to occur before entering

For REMOVE actions:
- Explain the bearish technical breakdown with specific indicator values
- Rationale MUST include: "Price has broken below $X support with [indicator] showing [value], suggesting downtrend"

ALWAYS reference actual numbers from the provided indicators in your rationale."""
        else:
            base_prompt += """
GENERAL MODE - Overview Analysis:

Action Mapping (for watchlist management):
- Buy: Strong technical setup, good entry point
- Wait: Mixed signals or not optimal timing
- Remove: Bearish signals, better opportunities elsewhere

Provide detailed rationale explaining your analysis and reasoning."""

        return base_prompt

    def _build_user_prompt(self, ticker: str, indicator_summary: str) -> str:
        """Build user prompt with ticker and indicators.

        Args:
            ticker: Stock ticker symbol
            indicator_summary: Formatted indicator summary

        Returns:
            User prompt string
        """
        base_request = f"""Perform comprehensive technical analysis for {ticker}.

# Technical Indicators:
{indicator_summary}

Analyze these indicators and provide:
1. Overall technical score (0-100)
2. Confidence level in your analysis (0-100)
3. Trading recommendation (strong_buy, buy, hold, sell, strong_sell)
4. Suggested watchlist action (Buy, Wait, Remove)
5. Detailed, fact-based rationale referencing specific indicator values
6. 2-4 key technical signals driving your analysis
7. 1-3 risk factors or caveats to consider
8. Trend assessment (bullish, bearish, neutral)
9. Entry timing recommendation (immediate, wait_for_pullback, wait_for_breakout, avoid)"""

        if self.prompt_mode == "tactical":
            base_request += """
10. SPECIFIC TRADING LEVELS:
    - If action is BUY: Provide entry_price (current or slightly better), stop_loss (below support), take_profit (at resistance, min 2:1 R:R)
    - If action is WAIT: Provide wait_for_price (specific pullback or breakout level to monitor)
    - If action is REMOVE: Set these fields to null

IMPORTANT: Your rationale MUST include specific price levels based on the technical indicators:
- For BUY: "Consider entering around $[entry_price] with stop loss at $[stop_loss] and take profit at $[take_profit] because..."
- For WAIT: "Wait for price to reach $[wait_for_price] (support/resistance level) before entering because..."
- For REMOVE: "Price has broken below $X with [indicator] at [value], suggesting..."

Use actual indicator values (moving averages, support/resistance from recent price action, ATR for stop placement).
"""

        base_request += """

Key Technical Considerations:
- RSI levels for overbought/oversold conditions
- MACD for momentum and trend changes
- Price relative to moving averages for trend confirmation
- Volume for conviction
- ATR for volatility and stop loss placement
- Bollinger Bands for price extremes
- Recent swing highs/lows for support/resistance

Provide your analysis in the required JSON format with ALL fields populated."""

        return base_request
